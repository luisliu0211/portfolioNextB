# 建立伺服器 simple web 前後端互動

collection: backend
tags: express.js, nodejs

---

### 簡易伺服器建立

<aside>
☝🏻 在node 環境 建立server.js  陽春！僅能接收請求回復

[iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/m/articles/10272180)

```jsx
const http = require('http'); // 引入node內建套件 http
const port = 3002; //設定接口
const fs = require('fs/promises'); //引入 npm i fs/promises 讀取檔案

// 建立伺服器處理用戶端發出http請求 收到請求後 回復對應的網頁內容

const server = http.createServer(async (request, response) => {
  // 建立伺服器： 處理req/ res      
```

### 設定response 回傳http的標頭(頭部訊息)

可以透過`setHeader`或是`writeHead`

前者只能設response header單個屬性內容;後者可以一次設置所有的狀態碼、響應頭、狀態資訊。

```jsx
writeHead(statusCode,[, StatusMessage[, headers]]);

response.writeHead(200,//狀態碼
  {'Content-Lenghth':'Buffer.byteLenght(body)',//告知瀏覽器發送的數據類型
  'Content-Type':'text/html;charset=UTF-8'});//具體會如何顯示數據
```

### 補充：

### **1.代表可以識別HTML的結構，並使用UFT-8編碼分析。**

```
'Content-Type':'text/html;charset=UTF-8'

```

### **3.代表設置圖片結構(png/jpg)。**

```
'Content-Type':'image/png'
'Content-Type':'image/jpg'
```

### **2.代表設置成純文本的結構，並不可識別Html的結構。**

```
'Content-Type':'text/plain'

```

[Node中setHeader和writeHead的区别](https://juejin.cn/post/7077951590157516837)

### 回傳respones的內容

可以不只是文字,可能是html, json……

在每個HTTP請求的最後都會調用end方法，就是結束響應，當客戶端請求完成後，都會被調用執行。

> 如果不調用end的話，客戶端就會一直等待，就像在使用瀏覽器時，網頁一直沒跑完的樣式
> 

```jsx
//邏輯上來說用swtich 抓取蒐集到的request http 網址 回覆對應的respones http
//回傳內容 response.end(’ 可以是文字 可以是檔案’)
switch (request.url) {
    case '/':
      response.end('首頁');
      break;
    case '/test':
      const content = await fs.readFile('test.html');
      // 使用fs/promises 讀取指定html檔案
      response.end(content);
      break;
    default:
      response.writeHead(404);
      response.end('Not Found');
  }
});
```

### 執行監聽

server物件，呼叫 listen()，它會在createServer()執行時，讓你決定要監聽哪一個port，並且開始監聽任何進來的requests

```jsx
server.listen(port, () => {
  console.log(`Server running at port ${port}`);
});
// 第二個參數利用callback 函式 印出目前正在執行哪個port
```

> 執行node server.js 後 伺服器會一直維持執行狀態 若有更動內容需要在重新執行 server.js 檔案
> 
> 
> 才會重新將資料寫入記憶體 否則僅只是存入在硬碟內尚未更新
> 

### 使用 nodemon 套件

npm i -g nodemon 安裝全域 

```
指令 nodemon server.js 可以監聽路徑底下所有檔案若有改變,自動重新啟動
```

[Day7 - Node.js 內建的 Web Server 介紹及使用 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/articles/10185302)

</aside>

### 現代做法 使用express 套件 中間件的世界！

express 是第三方套件，所以要先安裝 

```jsx
const express = require('express'); // 引入外部套件 express

require('dotenv').config(); // =>保護機敏文件

// 利用express 這個框架/ 函式庫 建立一個 web application
const app = express(); // 呼叫express 函式
const port = process.env.SERVER_PORT;

// app.[method]
// method: get/ post/ delete/ put/ patch...
app.get('/', (req, res) => {
  res.send('hello express');
}); // 當網址符合指定（第一個參數,執行callback一定會有req/res)

app.listen(port, () => {
  console.log(`server start at ${port} by express `);
});
```

### 中間件middleware

> express 世界幾乎所有東西都是中間件 ⇒ express是由中間件組成的
> 

**中間件的順序很重要**

Express 是按照你安排的順序去執行的 -> 按照順序決定誰是 nextmiddleware 有兩種結果:

- next: 往下一個中間件去
- response: 結束這次的旅程 req-res cycle

```jsx
// 路由中間件
app.get('/', (req, res, next) => {
res.send('hello express');
  console.log('這裡是首頁');
});

app.use((req, res , **next**) => {
console.log('這是中間件');
next();
});
// 一般中間件
```

<aside>
🔥 **res.send/ res.render/ res.json 差異 響應方法：**

| https://expressjs.com/zh-tw/4x/api.html#res.download | 提示您提供要下載的檔案。 |  |
| --- | --- | --- |
| https://expressjs.com/zh-tw/4x/api.html#res.end | 結束回應程序。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.json | 傳送 JSON 回應。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.jsonp | 傳送 JSON 回應，並支援 JSONP。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.redirect | 將要求重新導向。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.render | 呈現視圖範本。 | 若app.get() 路由中間件有寫第三個參數next(),則不會終止循環 |
| https://expressjs.com/zh-tw/4x/api.html#res.send | 傳送各種類型的回應。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.sendFile | 以八位元組串流形式傳送檔案。 |  |
| https://expressjs.com/zh-tw/4x/api.html#res.sendStatus | 設定回應狀態碼，並以回應內文形式傳送其字串表示法。 |  |
</aside>

指從發出請求(Request)之後，到接收回應(Response)這段來回的途徑上，用來處理特定用途的程式。

```jsx
// app.[method]
// method: get/ post/ delete/ put/ patch...
app.use((req, res, next) => {
  console.log('第1個中間件');
  // 一定要寫 next 讓express 知道要跳去下一個中間件 否則會一直轉圈圈
  next();
});

app.get('/', (req, res, next) => {
  res.send('hello express');
  console.log('這裡是首頁');
}); 
// 當網址符合指定（第一個參數,執行callback一定會有req/res)
// 只要有response 就結束了不能再覆寫

app.use((req, res, next) => {
  console.log('第2個中間件');
  next();
});

// 後面如果沒有中間件就結束回傳response的資訊
**// Express 會按照你程式碼的順序(由上到下)去決定 next 是誰
// 中間件裡一定要有 next 或者 response
// - next() 往下一關走
// - res.xxx 結束這次的旅程 (req-res cycle)
// - res.send('')
// - res.render('')
// - res.json('')**
```

<aside>
☝🏻 使用方法：app.use/ app.[method]

</aside>

### 中間件裡的可以執行的工作:

- 執行任何程式碼
- 改變 request 跟 response 物件 (TBA)
- 結束 req-res cycle → 寫res.xxx結束 參數可不寫next
- 呼叫下一個 middleware →寫next()

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled.png)

### middleware分類

比較常見的**Middleware**有身份驗證(Identity)、路由(Routing)或回應壓縮(Response Compression)等。

<aside>
🔥 中間件分類：

1. **Application-level middleware (一般中間件)**
    
    *可以被設定去處理每一個應用程式接收到的請求內容，如同前面的應用程式實作，當中所使用的 app.use() 、app.get() 、app.post() 等等，都是 application-level middleware的代表。*
    
    ```jsx
    // 使用 method-override
    app.use(methodOverride('_method'))
    // 查詢一張 picture 的詳細資料
    app.get('/pictures/:id', (req, res) => {
    })
    ```
    
2. **Router-level middleware (路由中間件)**
    
    *Router-level middleware 是屬於 express.Router() 的實例變數 (instance)的 middleware，使用方法跟 application-level middleware 一樣，範例如下：*
    
    ```jsx
    // 宣告一個名為 router 的 express.Router() 的實體
    const router = express.Router()   // 當請求的路由是 GET /todos/:id 時，執行 Router middleware
    router.get('/todos/:id', (req, res) => {
      // 查詢一個 todo 的詳細資料
    })
    ```
    
3. **Error-handling middleware (處理錯誤中間件)**
    
    *專門來處理錯誤狀況的 middleware，而 Express 的慣例是當一個 middleware 有四個參數時，就代表它是一個 error-handling middleware，所以撰寫 error-handling middleware 時必須提供四個參數，分別為 err、req、res 與 next。*
    
    ```jsx
    app.use(function (err, req, res, next) {
      console.error(err.stack)
      res.status(500).send('Something broke!')
    })
    ```
    
4. **Built-in middleware (內建)**
    
    *Express 當中有幾個內建的 middleware，幫助我們處理一些簡單的事情，如同，透過 express.static(‘public’) 可以讀取，由我們自行建立的靜態檔案，包含 JavaScript 、 CSS 檔案。*
    
    ```jsx
    app.use(express.static('public'))
    ```
    
5. **Third-party middleware (第三方中間件)**
    
    *Third-party middleware，則是由第三方所撰寫的套件，它需要透過 npm 下載使用，而 Third-party middleware 最大的好處，就是避免讓我們重複造輪子，可以直接引用他人的模組工具來解決自身的專案問題，如同 body-parser 。*
    
    ```jsx
    // 載入 body-parser
    const bodyParser = require('body-parser')
    // 使用 body-parser
    app.use(bodyParser.urlencoded({ 
       extended: true 
    }))
    ```
    
</aside>

<aside>
🔥 補充: pug HTML 套件

[精通 Pug 樣版語言（一）語法基礎篇 | Blog - 白花殿](https://www.shirohana.me/blog/articles/2020-mastery-pug-template-engine/)

HTML 的樣板語法，html 不認得，需要經過編譯

- 可加速 html 的開發
- 有復用與擴展機制
- 可以寫 loop 迴圈與 if-else 判斷式
- 編譯時，可以幫忙檢查語法是否正確
- 單獨使用
    
    ```
    # 安裝在全域即可，跨專案共用
    npm install -g pug-cli
    
    # 原始碼(pug 檔) 放在 src 檔案夾裡，編譯完成的 html 放在 src 檔案夾裡
    pug src/* -o dist
    
    ```
    
- 跟 Express 一起使用
    
    要在 express 專案裡安裝
    
    > npm i pug
    > 
    
    ```jsx
    // 設定 express 要用的樣版引擎(template engine)
    // 設定視圖檔案要放在哪裡
    app.set('views', path.join(__dirname, 'views'));
    // 要用哪一種 template engine
    // npm i pug
    app.set('view engine', 'pug');
    
    app.get('/ssr', (req, res, next) => {
      // 用 view engine 來渲染一個頁面
      // 這個 SSR (server-side render)
      // 會去 views 設定的檔案夾裡找 ssr.pug
      // 並且把變數 stocks 傳給 pug 去渲染
      res.render('index', {
        stocks: ['台積電', '長榮', '聯發科'],
      });
    });
    
    ```
    
- 使用語法：
    
    
    使用範例：(master.pug)
    
    ```jsx
    //- master.pug
    doctype html
    html
      head
        title MFEE
        meta(charset='utf-8') //(屬性值)
    
      body
        //-head.pug (引入同層head.pug)
        include head
        #content //(# ->id="content")
          block content
        //-footer.pug (引入同層footer.pug)
        include footer
    ```
    
    輸出主檔範例:  index.pug
    
    ```jsx
    extends _layouts/master 
    (將src裡面的主檔master匯入)
    
    block content
      h2 這裡是首頁
      table
        tr
          td col1
          td col2
        tr
          td col3
          td col4
    ```
    
    ### 資料夾結構
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%201.png)
    
    編譯後樣式：
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%202.png)
    
    編譯後樣式：
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%203.png)
    
    [精通 Pug 樣版語言（一）語法基礎篇 | Blog - 白花殿](https://www.shirohana.me/blog/articles/2020-mastery-pug-template-engine/)
    
    語法轉換練習：
    
    [PugPlay](https://pug.vercel.app/)
    
</aside>

## Restful API (Application Programming Interface (應用程式介面))

[API 是什麼? RESTful API 又是什麼?](https://medium.com/itsems-frontend/api-%E6%98%AF%E4%BB%80%E9%BA%BC-restful-api-%E5%8F%88%E6%98%AF%E4%BB%80%E9%BA%BC-a001a85ab638)

[https://www.youtube.com/watch?v=zvKadd9Cflc&t=10s&ab_channel=Termsoup](https://www.youtube.com/watch?v=zvKadd9Cflc&t=10s&ab_channel=Termsoup)

RESTful API 是一種設計模式，不一定都能符合，但盡可能接近

REST，全名 Representational State Transfer( 表現層狀態轉移)，**他是一種設計風格 不是標準**，RESTful 只是轉為形容詞，RESTful 則形容以此規範設計的 API，稱為 RESTful API

- 定義一組可以被操作的物件
- 用 HTTP Method  來表達動作
    - GET 讀取資源 (read讀取)
    - PUT 替換資源 (update更新)
    - PATCH 更換資源部分內容
    - DELETE 刪除資源(delete刪除)
    - OPTIONS 回傳該資源所支援的所有 HTTP 請求方法
    - CONNECT 將連線請求轉換至 TCP/IP 隧道
    - POST 新增資源(create新增)
    
    [HTTP method 介紹](https://www.notion.so/Http-Method-Http-CORS-9c2b2088e5ce4f8f8f0e2fa69e4558e8?pvs=21)
    

正好會對應到資料庫基本操作 CRUD 增刪查改。

> CRUD 為 Create(新增)、Read(讀取)、Update(更新)與Delete(刪除)的縮寫
> 

<aside>
🔥 若以 RESTful API 風格開發：

```
獲得資料GET     /data
新增資料POST    /data
刪除資料DELETE  /data/1
```

就是用一個唯一的 URL 定位資源，將動作藏在 HTTP 的 method 裡面。

</aside>

RESTful API 主要由三種元件組成：

![https://miro.medium.com/max/426/1*Vj-yqyvny36mMyk6Q5pXww.png](https://miro.medium.com/max/426/1*Vj-yqyvny36mMyk6Q5pXww.png)

1. Nouns 名詞：定義資源位置的 URL，每個資源在網路上都會有唯一的位置，就如每戶人家都有唯一的地址一樣。
2. Verbs 動詞：對資源要做的動作。
3. Content Types 資源呈現方式：API 資源可以以多種方式表現，最常用的是 JSON，較輕，也較好處理。

### RESTful API 優勢：

1. 有唯一的URL表示資源位置，統一的 API 接口。(Uniform Interface)
2. 無狀態。(Stateless)→
    
    RESTful 的狀態，意即 HTTP 的請求狀態。
    
    一般 Web 服務中，Server 端和 Client 端交互的資訊，**會存在 Server 端的 Session (例如：已登入狀態)**，在 Client 端再次發送請求的時候，Server 端透過保存在 Server 端的 Session，去執行 request。
    
    無狀態的意思，即 **Client 端自行保存狀態**，在請求 Server 的時候，一併附上給 Server 端，Server 端無保存 Client 端的狀態資訊。
    
    <aside>
    🔥 舉例來說，可能在用戶登錄系統時，Server 產生 token 紀錄 user 已登錄系統，**然後把 token 還給 Client**，在 Client 再次發送請求的時候，把 token 一起發給 Server，這樣 Server 就知道這一個 Client 是已經處於登錄的狀態。
    
    </aside>
    
3. 可更高效利用快取來提高回應速度 (Cachable)
    
    
    - 在 server-side，GET 過的資源，如果沒有被變更過，可以利用 cache 機制減少 request。
    
    - 在 client-side，透過 client 端 cache 紀錄 cache 版本，若向 server 要求資源時發現 server 最新版與 cache 相同，則 client 端直接取用本地資源即可，不需要再做一次查詢
4. 分層系統架構 (Layered System)
5. **客戶端服務器分離 (Client-Server)**
6. 充份利用 HTTP protocal(GET/POST/PUT/DELETE) (Manipulation of resources through representations)
7. 可執行程式碼的設計，像是 JavaScript（非必要實作項目） Code-On-Demand (optional)

e.g. GET /customers/1/orders

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%204.png)

## 和資料庫互動 createPool

[mySql→ **MySQL 2 connection pool**](https://www.notion.so/MySQL-84b415c828244e2298aeb76bb8ca2e07?pvs=21)

- 使用 connection pool --> 建議使用的方式
    - 建立一組連線給大家共用（重複使用）
- 原本爬蟲練習 →缺點: 慢(建立連線、釋放連線是很慢的事情)、連線數量無法控制(資料庫能承受的連線數有限)

```jsx
 // 引入 npm i mysql2
const mysql = require('mysql2');

let pool = mysql
  .createPool({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    **// 限制 pool 連線數的上限
    connectionLimit: 10,
    dateStrings: true, //mysql2套件會自動將日期轉換成javascript的日期物件 可以利用dateStrings 設定回來：保持date是 string**
  })
  .promise();
```

## 前後端互動

**已完成：後端 爬蟲抓取股票資料[axios 套件 前後端傳遞資料](https://www.notion.so/axios-b0ee81cb514945cb94948353aa8c6c34?pvs=21)** 

**已完成：將股票資料存入 資料庫互動 [axios 套件 前後端傳遞資料](https://www.notion.so/axios-b0ee81cb514945cb94948353aa8c6c34?pvs=21)** 

**已完成：後端利用express 製作伺服器 設定 api 網址 本頁上方**

### **接下來繼續： 前端利用後端api 網址抓取資料庫的資料 渲染在前端頁面**

1. 設定後端api 連動資料庫路徑：
    
    ```jsx
    //backend server.js
    
    // 列出所有股票代碼
    app.get('/api/1.0/stocks', async (req, res, next) => {
      console.log('/api/1.0/stocks');
      // 寫法1
      // let result = await pool.execute('SELECT * FROM stocks');
      // let data = result[0];
      // ES6 寫法 (寫法2)
      let [data] = await pool.query('SELECT * FROM stocks');
      res.json(data);
    });
    
    //列出某個股票代碼的詳細資料->（所有報價資料）
    app.get('/api/1.0/stocks/:stockId', async (req, res, next) => { 
      const stockId = req.params.stockId;**//:stockId 表示變數 用param取得**
      let [data] = await pool.query(
        'SELECT * FROM stock_prices WHERE stock_id =?', // sql語法
        [stockId]
      );
      //前端打api 時有拿到股票代碼 拿這個代碼在使用req.param.stockID後端取出變數
      res.json(data);
    });
    ```
    

3. 前端將抓取到的資料渲染頁面

```jsx
// 利用map 將data逐一放在需求的位置

{data.map((value, index) => {
        return (
          <div
            key={value.id}
            className="bg-white bg-gray-50 p-6 rounded-lg shadow hover:shadow-lg m-6 cursor-pointer"
          >
            <Link to={`/stock/${value.id}`}>
              <h2 className="text-2xl font-bold mb-2 text-gray-800">
                {value.id}
              </h2>
              <p className="text-gray-700">{value.name}</p>
            </Link>
          </div>
        );
      })}
```

```jsx
// 1. 這行以下的全站有效
app.use(express.json());

// 2. 這行以下的、同一個 router 裡有效
router.use(express.json());

// 3. 針對某一個特殊的路由 
router.post('/api/1.0/auth/login', (req, res, next) => {});
router.post('/api/1.0/auth/register', express.json(), (req, res, next) => {});

// 放一組
// 寫法 1 插在路由中間件裡面 第二個參數
router.post('/api/1.0/auth/register', express.json(), 第二個中間件, (req, res, next) => {});
// 寫法 2 插在路由中間件第二個參數（一個以上中間件做成陣列存）
router.post('/api/1.0/auth/register', [express.json(), 第二個中間件], (req, res, next) => {});
// 寫法 3 寫法2的陣列用變數存取
let middlewares = [express.json(), 第二個中間件];
router.post('/api/1.0/auth/register', middlewares, (req, res, next) => {});
```

1. 前端react 框架 向後端取資料
    
    ```jsx
    // frontend Stock.js
    
    //使用 axios 和後端要資料之後存在useState狀態裡使用
    const [data, setData] = useState([]);
    
    useEffect(() => {
        console.log('開始的資料', data);
        let getStock = async () => {
          let res = await axios.get('http://localhost:3002/api/1.0/stocks');
          console.log('抓到的資料', res);
          setData(res.data);
          console.log('抓到的資料(整理過)', data);
        };
        getStock();
      }, []);
    
    // frondend StockDetails.js
    
    //使用 axios 和後端要資料之後存在useState狀態裡使用
    const [data, setData] = useState([]);
    
    // 把網址上的 :stockId 拿出來
      const { stockId } = useParams(); **// 使用 useParam取得網址字串**
      console.log('StockID', stockId);
    
    useEffect(() => {
        console.log('StockID', stockId);
        let getStockDetail = async () => {
          let response = await axios.get(
            `http://localhost:3002/api/1.0/stocks/${stockId}`
          );
          setData(response.data);
        };
        getStockDetail();
      }, [])
    ```
    

### 補充：

> request.params => 變數在api網址上 ex: /stock/123
request.query => 變數在 query string 上 ex: /stock/123?page=1
request.body => form post
> 

[【 Node.js 】為什麼要使用 express bodyparser 呢？ - Jimmy 的架站筆記](https://jimmyswebnote.com/why-use-express-bodyparser/)

```jsx
// 要讓 express 認得 json
// 預設處理 Content-Type 是 "application/json" 的
app.use(express.json());

// express.urlencoded 要讓 express 認得 body 裡的資料
// extended: false -> querystring
// extended: true -> qs
// 預設處理 Content-Type 是 "application/x-www-form-urlencoded" 的
app.use(express.urlencoded({ extended: true }));

// 使用 multer
// Content-Type: multipart/form-data
```

### **來源**

- 我們自己開發的
- 第三方, e.g. cors
- express 內建的, e.g. express.json()

### **位置**

- app
- router
- 針對某一個特殊的路由

### cors 中間件 （跨源問題）[npm 套件](https://www.notion.so/npm-114585b3aff84212a5f1d753e852aaf0?pvs=21)

Cross-Origin Resource Sharing 跨源資源共享

「源」：同源 vs 跨源

- 通訊協定 protocol: http vs https 不同源
- 網域 domain name: `www.example.com` vs `api.example.com` 不同源
- 通訊埠 port: [www.example.com:3000](http://www.example.com:3000/) vs [www.example.com:3002](http://www.example.com:3002/) 不同源

[[教學] CORS 是什麼? 如何設定 CORS?](https://shubo.io/what-is-cors/)

ex: 小測試

```
origin: http://www.example.com
(1) http://api.example.com -> 跨 domain
(2) https://www.example.com -> 跨 protocol
(3) http://www.example.com:3000 -> 跨 port 3000
(4) http://www.example.com:80 -> 同
(5) http://www.example.com/test.html -> 同
```

> 不同源的前端若嘗試對**瀏覽器打api 會被擋下**,所以需要使用 cors 設定允許跨源
> 

「瀏覽器」不允許跨源的 AJAX 請求,後端網站可以允許跨源

- 前端port 3000 嘗試對 後端 port 3002 打api 被瀏覽器鎖起來
    
    基於安全性考量，程式碼所發出的跨來源 HTTP 請求會受到限制。例如，`[XMLHttpRequest](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest)`及 `[Fetch](https://developer.mozilla.org/zh-TW/docs/Web/API/Fetch_API)`都遵守[同源政策（same-origin policy）](https://developer.mozilla.org/zh-TW/docs/Web/Security/Same-origin_policy)。
    
    這代表網路應用程式所使用的 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源。
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%205.png)
    
    <aside>
    ☝🏻 跨來源請求的 Cookie
    
    一般的 http request 會帶有該網域底下的 cookie；然而，**跨來源請求預設是不能帶 cookie 的。**
    
    為什麼呢？因為帶有 cookie 的請求非常強大，如果請求攜帶的 cookie 是 session token，那這個請求可以以你的身份做很多機敏的事情，像是存取你的隱私資料、從你的銀行帳戶轉帳等。
    
    - `credentials`
    
    透過 fetch API 發送跨來源請求，需要設定 `credentials: 'include'`：
    
    ```jsx
    fetch('[https://othersite.com/data](https://othersite.com/data)', {
      credentials: 'include'
    })
    ```
    
    - `withCredentials`
    
    透過 XMLHttpRequest 發送跨來源請求，需要設定 `withCredentials = true;`
    
    ```jsx
    const xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.open('POST', '[https://othersite.com/data](https://othersite.com/data)');
    ```
    
    如此一來跨來源請求就會攜帶 cookie 了！
    
    </aside>
    

```jsx
**// 第三方套件，要先安裝: npm i cors**
const cors = require('cors');
// 使用這個第三方提供的 cors 中間件
// 來允許跨源存取 // 前端port 3000 後端 port 3002
// 預設都是全部開放
// app.use(cors());
// 使用情境: **當前後端網址不同時，只想允許自己的前端來跨源存取**
//          就可以利用 origin 這個設定來限制，**不然預設是 * (全部)**
const corsOptions = {
   origin: ['http://localhost:3000'],
 };
 app.use(cors(corsOptions));

// 若沒帶入物件參數 則開放全部前端都可以跨源打api 若帶入指定url 網址物件,
// 則可以指定該網址可以跨源
```

<aside>
🔥 Server 端也需要額外的設定：如果是信任的來源，回應要帶有 `Access-Control-Allow-Credentials` header：

```jsx
Access-Control-Allow-Credentials: true
```

如此一來，瀏覽器才會將 cookie 寫進該 domain。

</aside>

> 由於是從後端 3002 打api 到外部網站取得資料後存在資料庫
> 
> 
> 然後前端3000 打api 通知後端3002提供資料 有跨域問題 因此使用 cors套件解決
> 

```jsx
const corsOptions = {
  origin: ['http://localhost:3000'],
};
app.use(cors(corsOptions));
// 若沒帶入物件參數 則開放全部前端都可以跨源打api 若帶入指定url 網址物件,則可以指定該網址可以跨源
```

## 以上做完後…增添進階功能

### 分頁功能-後端

- 前端分頁: 所有的資料都拿到前端後，由前端來分頁
    - **優點: 請求只有1次，後續的換頁會很快（因為前端已經有全部的資料）**
    - 缺點: 第一次就把資料拿全，負擔很重(資料庫、傳輸量)，使用者通常不會看到後面幾頁的資料

<aside>
👉🏻 製作前端分頁 ：可參考react 作法 or 引入套件 or javascript

</aside>

- 後端分頁: 前端每次只跟後端拿該頁的資料
    - 優點: 不用拿全部資料，只拿需要的就好
    - 缺點: 每次換頁都需要去跟後端拿一次資料

<aside>
🔥 製作 後端分頁 任務：在後端分批取出資料給前端處理渲染畫面

### 後端設定需要抓取的資料內容 —>比照右方程式碼

- [ ]  A. 決定一頁要有幾筆 perPage
- [ ]  B. 從 query string 取得目前在第幾頁，要有預設值，沒有設定就是要第一頁的資料 page
- [ ]  C. 從資料庫取得該股票代碼的總筆數 total
- [ ]  D. 從 total 與 perPage 算出總頁數 lastPage (hint: Math.ceil)
- [ ]  E. 計算取得該頁資料須要跳過幾筆 offset
- [ ]  F. 根據 perPage 及 offset 從資料庫取得該頁資料
- [ ]  G. 回傳資料: pagination (前端可能需要的頁碼資料)與 data

```sql
- 注意 mysql2 套件回傳的資料格式
SELECT COUNT(*) AS total FROM stock_prices WHERE stock_id=?
SELECT * FROM stock_prices WHERE stock_id = ? ORDER BY date LIMIT ? OFFSET ?
```

```jsx
// backend server.js
app.get('/api/1.0/stocks/:stockId', async (req, res, next) => {
  const stockId = req.params.stockId;
  // 後端分頁 ->在後端分批取出資料給前端

  **// B. 透過query string 取得前端打來的api網址資料（第幾頁） 或沒設定就是預設第一頁資料**
  let page = req.query.page || 1; 
  const perPage = 5; //A. 設定每頁顯示筆數（每次換頁抓取筆數）

  //C. TODO: 查詢資料庫 ：取得總筆數 ex: 57 (sql 語法可使用)
  let [total] = await pool.execute(
    'SELECT COUNT(*) AS total FROM stock_prices WHERE stock_id =?',
    [stockId]
  );
  total = total[0].total;
  // sql 語法皆 會回傳陣列[{total:'筆數'}] 因此還要多處理
  //D. TODO:取得總頁數  --> 總筆數/ 每頁顯示筆數 （無條件進位）
  let lastPage = Math.ceil(total / perPage);

  //E. TODO:計算 offset (在sql語法裡面代表跳過哪些資料不拿取)
// offset 在頁碼的概念就是： 假設每頁顯示5筆資料 第二頁顯示6-10筆資料 因此跳過前5筆 從第6筆開始抓取
// 第一頁 1-5
// 第二頁 6-10

  const offset = perPage * (page - 1);

  // sql 語法 'SELECT * FROM stock_prices WHERE stock_id =? ORDER BY date LIMIT perPage OFFSET offset',  

  //F. TODO:根據以上取得資料
  let [data] = await pool.execute(
    'SELECT * FROM stock_prices WHERE stock_id =? ORDER BY date LIMIT ? OFFSET ?',
    [stockId, perPage, offset]
  );
  // G. 將資料整理好方便前端打api取用  ->前端打api來的時候 就會提供這包資料
  res.json({
    pagination: {
      total: total,
      perPage: perPage,
      page: page,
      lastPage: lastPage,
    },
    data,
  });
```

### 前端設定頁碼狀態＆ 渲染樣式—>比照右方程式碼

- [ ]  A. 增加 lastPage(總頁數) 與 page (目前在第幾頁) 的 state
- [ ]  B. 先開發頁碼，可以透過修改 lastPage 與 page 這兩個 state 的預設值來測試
- [ ]  C. 頁碼點擊後，要 setPage 去改變 page state
- [ ]  D. 從後端取得資料後，要從 pagination 物件裡取得總頁數 (lastPage)
- [ ]  E. 在 page 的 effect 去後端取得該頁資料

> hint: 當我們在設定 state 預設值時，也會觸發 useEffect
> 

B. 製作頁碼樣式 用javascript push 方法放在return 裏面

```jsx
const getPages = () => {
    //製作存取頁碼容器(陣列)
    let pages = [];
    for (let i = 1; i <= lastPage; i++) {
      pages.push(
        <li
          style={{
            display: 'inline-block',
            margin: '2px',
            backgroundColor: page === i ? '#00d1b2' : '',
            borderColor: page === i ? '#00d1b2' : '#dbdbdb',
            color: page === i ? '#fff' : '#363636',
            borderWidth: '1px',
            width: '28px',
            height: '28px',
            borderRadius: '3px',
            textAlign: 'center',
          }}
          key={i}
          onClick={(e) => {
            setPage(i); // C. 修改page狀態 撈後端資料
          }}
        >
          {i}
        </li>
      );
    }
    return pages;
  };
```

```jsx
// A. 設定頁碼狀態
  const [lastPage, setLastPage] = useState();
// 目前在第幾頁
  const [page, setPage] = useState(1);// 預設第一頁

  // 把網址上的 :stockId 拿出來 打api用
  const { stockId } = useParams();

  console.log('StockID', stockId);
  // D. 將收集到的資料去後端撈
  useEffect(() => {
    console.log('StockID', stockId);
    let getStockDetail = async () => {
      let response = await axios.get(
        `http://localhost:3002/api/1.0/stocks/${stockId}?page=${page}`
      );
      // 2. setData
      setData(response.data.data);
      // D. 從後端取得總頁數更新渲染
      setLastPage(response.data.pagination.lastPage);
    };
    getStockDetail();
  }, [page]); //E. 打api 時機： 一開始載入此頁面 ＆pages有更新狀態的時候
```

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%206.png)

</aside>

### 模組化

- CJS: CommonJS，不是 JS 內建的，**NodeJS 有實現 → 瀏覽器不能用**，除非像是 webpack 等工具有協助轉譯module.exports / require

[node js module 概念](https://www.notion.so/node-js-module-398af524446b4cf980b233b018dd5554?pvs=21) 

```jsx
let fs = require('readfile/promise');
// 從外部或者內建套件引入

```

- ESM: ES2015 module → JS 內建的模組export / import, Nodejs 也支援

[https://www.youtube.com/watch?v=qJWALEoGge4&ab_channel=uidotdev](https://www.youtube.com/watch?v=qJWALEoGge4&ab_channel=uidotdev)

### 整理code/ 處理機敏資訊 -前端

新增utils檔案夾 將前端的設定放在config.js裏面 —> 記得不要push 上去github

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%207.png)

.env 加上以 REACT_APP_ 開頭的環境變數設定

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%208.png)

讓全站程式碼可以共用設定，而不是把設定(像是後端網址)散落在程式碼的各處, 可將magic number 設定在config檔統一處理

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%209.png)

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2010.png)

> Refactor 重構
> 
> 
> 「在不改變軟體外部行為的前提下，改變其內部結構，使其更容易理解且易於修改」
> 

### 後端資料庫存取獨立成module

1. 建立通用資料夾utils 把server.js 裏面關於資料庫連動的模組放入db.js, 記得也添加所需的引用檔 ex. mysql2…

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2011.png)

1. 在server.js 引入 db.js 模組

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2012.png)

1. router 是express 裡面內建的 mini-app 
    
    <aside>
    ☝🏻 `express.Router`類別用來建立可裝載的模組路由處理程式。
    
    - 範例
        
        ```jsx
        var express = require('express');
        var router = express.Router();
        
        // middleware that is specific to this router
        router.use(function timeLog(req, res, next) {
          console.log('Time: ', Date.now());
          next();
        });
        // define the home page route
        router.get('/', function(req, res) {
          res.send('Birds home page');
        });
        // define the about route
        router.get('/about', function(req, res) {
          res.send('About birds');
        });
        
        module.exports = router;
        ```
        
        然後將路由器模組載入應用程式中：
        
        ```jsx
        var birds = require('./birds');
        ...
        app.use('/birds', birds);
        ```
        
        應用程式就能夠處理發給 `/birds`和 `/birds/about` 的要求，並且呼叫該路由特定的 `timeLog`中介軟體函數
        
    
    `Router`實例是一個完整的中介軟體與路由系統； 因此，常被稱為「迷你應用程式」。
    
    </aside>
    
    Router 起手式： 另外建立mini app 當作外掛回原本app 的渠道 之後在server.js 取用
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2013.png)
    

1. 建立router資料夾 將打api 相關的app.get(’’XXX,) 程式放入 stock.js 使用express 裡面的Router方法 原本app改成router
    
    ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2014.png)
    
1. 回到server.js 裏面 通知原本 express 有外掛一個 router 可引入取用 用app.use()

> 可以同時整理相似api網址 →  app.use(’/api/1.0/stocks’,stockRouter) 代表所引用的stockRouter 裡面的router.get() 都是使用/api/1.0/stock的前綴prefix
> 

// 或是把共用的網址抽出來放在這裡
// 這樣 router 裡只需要寫不一樣的地方就可以了

```jsx
// 通知app 外掛一個router mini-app stock 模組 可以用同個網址/api/1.0/stocks/
let stockRouter = require('./routers/stocks');
app.use('/api/1.0/stocks', stockRouter);
```

> app 能用的功能 router大多都能用： router.use(), router.get(), router.post()
> 

[[node]express中app.use和app.get的区别及解析_梧桐和风的博客-CSDN博客_app.use](https://blog.csdn.net/wthfeng/article/details/53366169)

後端資料夾結構如下參考：

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2015.png)

### 註冊功能 - 前端傳送註冊資料

- 整理輸入的資料
    
    
    - 使用register.js 增加 useState 狀態 可透過onChange修改內容
        
        ```jsx
        // 會員狀態 state 可分開 但建議類似的可以存成一個物件處理
          // 如果是一般非物件的state可以使用js 原生去改變值 ex onChange/ onClick ... 更新setXXX()即可
          // 但是把物件存在useState裏面無法按此操作(),需要複製成一個新物件,覆蓋回去原本的預設值。
          const [member, setMember] = useState({
            email: 'luis.com',
            name: 'luis',
            password: 'testtest',
            confirmPassword: 'testtest',
            photo: '',
          });
          //const [mail, setMail] = useState('luilui');
        //----------------------------------------------------------------------------------------------//
        <div className="mb-4 text-2xl">
                <label htmlFor="name" className="flex mb-2 w-32">
                  Email
                </label>
                <input
                  className="w-full border-2 border-purple-200 rounded-md h-10 focus:outline-none focus:border-purple-400 px-2"
                  type="text"
                  id="email"
                  name="email"
                  // member.email 是 react
                  value={member.email}
                  onChange={(e) => {
                    // 原生的其實有改變 
                    console.log(e.target.value); //是有值 但無法覆蓋 需要用setMember() 將整個member資訊覆蓋過去
                    // 不能直接去動 state -->  
                    // member.email = e.target.value; 
                    // setMember(e.target.value); **// uncontrolled 問題**
        
                    解法：          
                    **// 把原本的 member 複製一個出來 修改該物件的某的key值 在覆蓋回去setMember()**
                    let newMember = { ...member };
                    newMember.email = e.target.value;
                    setMember(newMember);
                  }}
                />
              </div>
        
        ```
        
    
    - 同樣內容可拉出來獨立成一個函式處理 綁定在對應input
        
        > 因為input欄位的name屬性內容和物件的變數事先設定相同所以可以利用此點取值
        > 
    
    抓取input 的文字內容 type= name, password,email… 文字
    
    ```jsx
    function handleChange(e) {
        console.log('handleChange', e.target.name, e.target.value);
        let newMember = { ...member };
        newMember[e.target.name] = e.target.value;
        setMember(newMember);
    
        // 比較潮的寫法 ES6 
        **// setMember({ ...member, [e.target.name]: e.target.value });**
      }
    ```
    
    抓取上傳檔案 type= file
    
    ### 前端綁定上傳圖片的功能
    
    ```jsx
    function handleUpload(e) {
        // type=file 的 input
        **// 選好的檔案是放在 e.target.files[0]**
        setMember({ ...member, photo: e.target.files[0] });
      }
    ```
    
- 傳送給後端
    
    有沒有上傳圖片 做法會不同：
    
    - 打api送回後端—-無上傳檔案作法：
        
        ```jsx
        async function handleSubmit(e) {
            // 把預設行為關掉
            e.preventDefault();
            try {
              // 方法1: 沒有圖片上傳、單純 post 一個 json 物件
              let response = await axios.post(`${API_URL}/auth/register`, member);
              console.log(response.data);
            } catch (e) {
              console.error('register', e);
            }
          }
        ```
        
        用物件傳到後端的資料會被標**Content-Type: application/json** 
        
        ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2016.png)
        
        ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2017.png)
        
        ```jsx
        
        **// server.js** 
        //若要讓express 認得傳入的json資訊 需要再設定中間件 存取資料
        app.use(express.json()); // 需要放在傳輸資料的最前方 讓程式先跑過 順序問題
        ```
        
        > //若介意效能問題可以../
        //1. 寫在router 裡面 ex: router.ues(express.json())
        //2. 針對特定中間件 放在路由中間件使用 ex router.post('/api/1.0XXX',express.json(),(req,res,next)=>{}) 但其他的就傳不到json()
        > 
        
    
    - 打api送回後端—-**有上傳檔案作法**：
        
        ```jsx
            // 方法2: 要上傳圖片 FormData
              let formData = new FormData();
              formData.append('email', member.email);
              formData.append('name', member.name);
              formData.append('password', member.password);
              formData.append('confirmPassword', member.confirmPassword);
              formData.append('photo', member.photo);
              let response = await axios.post(`${API_URL}/auth/register`, formData);
        ```
        
        用formData 傳到後端的資料會被標**Content-Type:** multipart/form-data
        
        ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2018.png)
        
        ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2019.png)
        
        express 內建無法讀取form-data格式 需要載入套件multer [npm 套件](https://www.notion.so/npm-114585b3aff84212a5f1d753e852aaf0?pvs=21) 
        
        ```jsx
        const multer = require('multer');
        // 設定圖片存入位置
        const storage = multer.diskStorage({
          **// 設定存在硬碟**
          // 手動建立設定存在哪個檔案夾 -> public/upload
          destination: function (req, file, cb) {
            console.log('des,file', file);
            // 規定寫法
            // path.join 避免不同作業系統之間的 / 或 \
            // __dirname 目前檔案的位置，用 __dirname 就可以不用管是在哪裡執行程式的
            cb(null, path.join(__dirname, '..', 'public', 'uploads')); //比較保險 避免不同作業系統之間差異
            // cb(null, __dirname + '/../public/uploads'); // 可以這樣寫
          },
          **//圖片名稱**
          filename: function (req, file, cb) {
            console.log('filename', file);
            // file.originalname //原始檔名這樣抓 test.png
            const ext = file.originalname.split('.').pop(); //用split()拆分後取最後一個值
            cb(null, `member-${Date.now()}.${ext}`); 
            //重新命名檔名 member-時間.副檔名 或者用uudi取隨機不重複的亂碼取名 
          },
        });
        // 設定成中間件
        const uploader = multer({
          // 傳到哪
          storage: storage,
          // 過濾圖片種類
          fileFilter: function (req, file, cb) {
            if (
              file.mimetype !== 'image/jpeg' &&
              file.mimetype !== 'image/jpg' &&
              file.mimetype !== 'image/png'
            ) {
              cb(new Error('上傳的檔案型態不接受'), false);
            } else {
              cb(null, true);
            }
          },
          // 過濾圖片大小
          limits: {
            // 500k
            fileSize: 500 * 1024,
          },
        });
        // 加回中間件 放在驗證之前
        router.post(`/api/1.0/auth/register`, **uploader.single('photo'),**registerRules,
          async (req, res, next) => {
        console.log('register', req.body, **req.file**); 
        // 後端抓到前端來的member物件資料 用req.body取用
        /*{
          email: '0f1ffff0eeeefe0lfuis@jiji.com',
          name: 'of1offffjennyeeeee',
          password: 'testtest',
          confirmPassword: 'testtest'
        }*/
        // 前端來檔案資料被放在req.file取用
        /*{
          fieldname: 'photo',
          originalname: 'æ\x88ªå\x9C\x96 2022-12-14 ä¸\x8Bå\x8D\x881.03.52.png',
          encoding: '7bit',
          mimetype: 'image/png',
          destination: '/Users/liuxueru/Desktop/nextjs workshop/simple-web/stock-be/public/uploads',
          filename: 'member-1671180881463.png',
          path: '/Users/liuxueru/Desktop/nextjs workshop/simple-web/stock-be/public/uploads/member-1671180881463.png',
          size: 255692
        }*/
        //...//
          }
        );
        
        ```
        
    
    [[Node.js]實作multer檔案上傳(二) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/articles/10231465)
    

- 驗證傳過去的資料
    - [x]  確認資料有沒有收到: 使用 `express.json` 中間件
    
     資料的驗證 **後端不可以相信來自前端的資料(資料驗證)**
    
    - [x]  檢查 email 有沒有重複
        - [ ]  如果有，回覆 400 跟錯誤訊息
    - [x]  密碼要雜湊 hash
    - [x]  資料存到資料庫
    - [ ]  回覆前端
1. 密碼檢查
    
    [密碼學  ****Encode、Encrypt 跟 Hash****](https://www.notion.so/Encode-Encrypt-Hash-1c58a0208cb74402b23c31ec71ad936d?pvs=21)
    
    > 密碼雜湊開發初期就必須決定,無法中途更換演算法
    > 
    
    ### 第三方套件： [npm 套件](https://www.notion.so/npm-114585b3aff84212a5f1d753e852aaf0?pvs=21)
    
    - md5(雜湊）每次雜湊結果都一樣 **可以被反查 彩虹表**
    - bcrypt  -推 （每次雜湊都不同）需用async 包promise 無法返解
        
        ```jsx
        const bcrypt = require('bcrypt');
        
        (async () => {
          let result1 = await bcrypt.hash('test', 10);  //最長60
        //參數第一個實際密碼 第二個雜湊後的字元數量
          console.log('result1:', result1);
          let result2 = await bcrypt.hash('test', 10);
          console.log('result2:', result2);
        })();
        ```
        
    - argon2-  （每次雜湊都不同）需用async 包promise 無法返解 建議新專案
        
        ```jsx
        const argon2 = require('argon2');
        
        (async () => {
          let result3 = await argon2.hash('test', 10);//最長96
          console.log('argon2:1', result3);
          let result4 = await argon2.hash('test', 10);
          console.log('argon2:2', result4);
        })();
        ```
        

1. 回覆前端
    
    ### **資料驗證 validator**
    
    [[筆記] 把玩 express-validator 在伺服器端做表單驗證](https://medium.com/%E9%BA%A5%E5%85%8B%E7%9A%84%E5%8D%8A%E8%B7%AF%E5%87%BA%E5%AE%B6%E7%AD%86%E8%A8%98/%E7%AD%86%E8%A8%98-%E6%8A%8A%E7%8E%A9-express-validator-%E5%9C%A8%E4%BC%BA%E6%9C%8D%E5%99%A8%E7%AB%AF%E5%81%9A%E8%A1%A8%E5%96%AE%E9%A9%97%E8%AD%89-797342aab2d3)
    
    - 前端驗證: UX 快速地讓使用者知道他的輸入有問題 (html / jquery 都有validata套件)
    - 後端驗證: 為了資料安全、資料乾淨 (後端 可使用express-validator)
    
    > 使用react 框架 HTML表單驗證可能失效
    > 
    
    ### 引用express-validator 套件  [npm 套件](https://www.notion.so/npm-114585b3aff84212a5f1d753e852aaf0?pvs=21)
    
    在後端server.js 處理驗證前端的資料
    
    ```jsx
    // npm i express-validator
    const { body, validationResult } = require('express-validator');
    // 引入express 驗證 利用中間件方式檢查
    
    // 從 body 取各欄的input name屬性值套入套件裡的函式並搭配預計回傳的文字
    const **registerRules** = [
      // 中間件： 檢查email是否合法
      body('email').isEmail().withMessage('Email欄位請填寫正確格式'),
      // 中間件：檢查密罵長度
      body('password').isLength({ min: 8 }).withMessage('密碼長度至少為8'),
      // 中間件： 檢查password &confirmed password 是否一致
      // 客製custom()中間件的條件
      body('confirmPassword')
        .custom((value, { req }) => {
          return value === req.body.password;
        })
        .withMessage('密碼不一致'),
    ];
    // **registerRules**包成陣列當作中間件放入
    router.post(`/api/1.0/auth/register`,**registerRules**, async (req, res, next) => {
    // 當路由匹配成功進入**registerRules中間件 會得到req 從validationResult取用req 的結果**
    
    const validationResult = validationResult(req);
      console.log('validationResult', validateResult);
    **/*validationResult Result {
      formatter: [Function: formatter],
      errors: [
        {
          value: 'luis',
          msg: 'Email欄位請填寫正確格式',
          param: 'email',
          location: 'body'
        },
        {
          value: 'test',
          msg: '密碼長度至少為8',
          param: 'password',
          location: 'body'
        },
        {
          value: 'testtes',
          msg: '密碼不一致',
          param: 'confirmPassword',
          location: 'body'
        }
      ]**
    }*/
    // 若驗證成功無誤 validationResult 取不到值 進入下個中間件  若有值代表驗證失敗 回傳失敗提示 
      if (!validateResult.isEmpty()) {
        return res.status(400).json({ erros: validateResult.array() });
      }
    //.....
      }
    });
    
    ```
    

1.  使用 `express.json` 中間件
    
    ```jsx
    //若要讓express 認得傳入的json資訊 需要再設定中間件 存取資料
    app.use(express.json()); // 需要放在傳輸資料的最前方 讓程式先跑過 順序問題
    //若介意效能問題可以../
    //1. 寫在router 裡面 
    ex: router.ues(express.json())
    //2. 針對特定中間件 放在路由中間件使用 
    ex: router.post('/api/1.0XXX',express.json(),(req,res,next)=>{}) 但其他的就傳不到json()
    ```
    
2. 檢查 email 有沒有重複
    
    如果有，回覆 400 跟錯誤訊息
    
    ```jsx
    router.post(`/api/1.0/auth/register`, async (req, res, next) => {
      console.log('register', req.body); 
      // 後端抓到前端來的member物件資料 用req.body取用
      // res.json({}); // 檢查 res回傳給後端的json 資料
      // 方法1 給DB 檢查 把email 欄位設定成uniqle(整張資料表的email不得重複)
      // 方法2 和資料庫撈撈看是否email已經存在,抓到變數打api查是否有資料 (方法1/2可並行）耗效能
      let [member] = await pool.execute(`SELECT * FROM members WHERE email=?`, [
        req.body.email,
      ]);
      // [data,fields]
      // let data = result[0];
      if (member.length == 0) {
      } else {
      //如果有，回覆 400 跟錯誤訊息
        return res.status(400).json({ message: '此email 已經註冊過' });
      }
    });
    ```
    

4.  存資料庫

```
router.post(`/api/1.0/auth/register`, 
**uploader.single('photo'), //圖片上傳**
registerRules, //資料驗證
async (req, res, next) => {
  // console.log('register', req.body); // 後端抓到前端來的member物件資料 用req.body取用
  **//  去資料庫撈撈看是否email已經存在**
  let [member] = await pool.execute(`SELECT * FROM members WHERE email=?`, [
    req.body.email,
  ]);

  if (member.length == 0) {
    // 初步檢查沒有重複email註冊 才做下一步
    // 將密碼資料雜湊轉換
    let hashedPassword = await bcrypt.hash(req.body.password, 10);
    **// 資料存到資料庫 

    // 連同路徑一起存入資料庫
    let filename = req.file ? '/uploads/' + req.file.filename : '';
    //TODO:  資料存到資料庫
    let result = await pool.execute(
      `INSERT INTO members (email,password,name,photo) VALUES (?,?,?,?)`,
      [req.body.email, hashedPassword, req.body.name, filename]
    );**
    console.log('註冊的資料', result);// **pool.execute 回傳皆為陣列**
    //TODO:  回覆前端
    res.json({ message: 'ok! 註冊成功' }); // 檢查 res回傳給後端的json 資料
  } else {
    return res.status(400).json({ message: '此email 已經註冊過' });
  }

 **//會有 race condition 的問題**
});
```

[JavaScript - async/await 的 race condition](https://toy9986619.medium.com/javascript-async-await-%E7%9A%84-race-condition-20927705569)

[Day15 - node.js使用靜態檔案服務 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/articles/10186000)

- ** 為檔案製作靜態服務 Express 託管靜態檔案
    
    通過 Express 內建的 express.static 可以方便地託管靜態檔案，例如圖片、CSS、JavaScript 檔案等。
    
    將靜態資原始檔所在的目錄作為引數傳遞給 express.static 中介軟體就可以提供靜態資原始檔的訪問了。例如，假設在 public 目錄放置了圖片、CSS 和 JavaScript 檔案，你就可以：
    
    ```jsx
    app.use(express.static('public'));
    ```
    
    現在，public 目錄下面的檔案就可以訪問了。
    
    `http://localhost:3000/images/kitten.jpg
    http://localhost:3000/css/style.css
    http://localhost:3000/js/app.js
    http://localhost:3000/images/bg.png
    http://localhost:3000/hello.html`
    
    所有檔案的路徑都是相對於存放目錄的，因此，存放靜態檔案的目錄名不會出現在 URL 中。
    
    如果你的靜態資源存放在多個目錄下面，你可以多次呼叫 express.static 中介軟體：
    
    ### 虛擬路徑
    
    如果希望所有通過 express.static 訪問的檔案都存放在一個“虛擬（virtual）”目錄（即目錄根本不存在）下面，可以通過為靜態資源目錄[指定一個掛載路徑](http://www.expressjs.com.cn/4x/api.html#app.use)的方式來實現，如下所示：
    
    ```jsx
    app.use('/static', express.static('public'));
    ```
    
    現在，你就可以通過帶有 “/static” 字首的地址來訪問 public 目錄下面的檔案了
    
    `http://localhost:3000/static/images/kitten.jpg
    http://localhost:3000/static/css/style.css
    http://localhost:3000/static/js/app.js
    http://localhost:3000/static/images/bg.png
    http://localhost:3000/static/hello.html`
    

```jsx
//設置靜態檔案
// express.static => 讓靜態檔案可以有網址
// http://localhost:3002/uploads/檔案名稱
app.use(express.static(path.join(__dirname, 'public')));
// 或是給 prefix
// http://localhost:3002/public/uploads/檔案名稱
// 虛擬路徑
// app.use('/public', express.static(path.join(__dirname, 'public')));
```

### 登入登出功能 -比對前端資料 網站登入狀態 登出狀態

1. 比對前端資料
    
    ```jsx
    router.post(`/api/1.0/auth/login`, async (req, res, next) => {
      // 抓取登入資料
      **//TODO 是否做資料驗證 可不做 （因為註冊已經有把關了）**
      //TODO 是否email有註冊過 如果沒有註冊過 回覆400
      console.log('login data', req.body);
      try {
        let [members] = await pool.execute(`SELECT * FROM members WHERE email=?`, [
          req.body.email,
        ]);
        // 初步檢查沒有重複註冊 才做下一步
        if (members.length == 0) {
          // 如果等於0 代表沒有資料
          return res.status(400).json({ message: '密碼或email錯誤' }); //錯誤訊息不能寫太明確給駭客機會
        }
        let member = members[0];
        // 密碼比較
        //TODO 如果密碼不對 回覆 401
        let compareResult = await bcrypt.compare(
          req.body.password,
          member.password
        ); **// 因為密碼是用bcrypt 雜湊存入 需使用bcrypt.compare 比較是否相同 回覆true or false**
        if (!compareResult) {
          return res.status(401).json({ message: '密碼或email錯誤' });
        }
        res.json({ message: '登入成功' });
    
        //  **如果密碼正確 修改狀態登入成功 1. jwt token 2. session/cookie -->下一步驟**
      } catch (e) {
        console.error(e);
      }
    });
    ```
    
2. 確認密碼正確設定session 回瀏覽器的cookie

[session vs cookie ](https://www.notion.so/session-vs-cookie-0dd49a04963c4d84a87d987852b10b05?pvs=21) [JWT token TBA](https://www.notion.so/JWT-token-TBA-03b655d759354c779c3aad7742924976?pvs=21) 

### 載入套件 express-session [npm 套件](https://www.notion.so/npm-114585b3aff84212a5f1d753e852aaf0?pvs=21)

預設存在記憶體 但nodejs 重開會釋放記憶體空間session 就會不見

<aside>
☝🏻 session 要有地方存: **記憶體、硬碟、資料庫**

練習時存硬碟就可以了

**所以業界常用存在硬碟 讀取較慢→ connect-redis —>業界常用 (需載套件）**

**開發用存在檔案 擴充較差 →session-file-store （需載套件）**

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2020.png)

</aside>

```jsx
// server.js
// 啟用session
const FileStore = require('session-file-store')(expressSession);
// 啟用session
const expressSession = require('express-session');
// session 存入地方的配置 session-file-store 把session 存在硬碟中
const FileStore = require('session-file-store')(expressSession);
//當作中間件使用;
app.use(
  expressSession({
    // 設定存入的地方
    store: new FileStore({
      // 設定session路徑
      path: path.join(__dirname, '..', 'sessions'),
    }),
    // 設定加密密碼 千萬不要寫 用變數存機敏資料
    secret: process.env.SESSION_SECRET,
    // 如果session 沒有改變是否要重新儲存
    resave: false,
    // 還沒初始化的 未登入的資料 要不要存成session?
    saveUninitialized: false,
  })
);
```

> 注意格式勿錯 否則很難除錯
> 

```jsx
// server.js 

const corsOptions = {
  // // 如果要讓 cookie 可以跨網域存取，這邊要設定 credentials
  // // 且 origin 也要設定
   credentials: true,
   origin: ['http://localhost:3000'],
};
app.use(cors(corsOptions));
```

> 可使用useContex() react hook 全站查詢是否已登入狀態
> 

```jsx
// auth.js
router.post(`/api/1.0/auth/login`, async (req, res, next) => {
  // 抓取登入資料
  **//TODO 是否做資料驗證 可不做 （因為註冊已經有把關了）**
  //TODO 是否email有註冊過 如果沒有註冊過 回覆400
  console.log('login data', req.body);
  try {
 //.//
    // 如果密碼正確 修改狀態登入成功  -->存入session
    let saveMember = {
      id: member.id,
      name: member.name,
      email: member.email,
      photo: member.photo,
    };
    // 把資料寫進去 session 裡面
    **req.session.member = saveMember;
// 將會員資料設進去session.member 如果session.member 有值則代表登入狀態**
    // 回覆前端 可以拿去給前端渲染用
    res.json(saveMember);

  } catch (e) {
    console.error(e);
  }
});

// 製作登出api
router.get('/api/1.0/auth/logout', (req, res, next) => {
  res.json({ message: '登出成功' });
});
```

前端login.js抓資料的時候 也需要設定 **withCredentials: true(axios)**   

**只要需要判斷是否登入跨源問題就需要加上**

```jsx
// front-end login.js
async function handleSubmit(e) {
    e.preventDefault();
    let response = await axios.post(`${API_URL}/auth/login`, loginMember, {
      // 為了可以跨源存取 cookie
      withCredentials: true, 
    });
    console.log(response.data);
    // 告訴 auth context 會員有資料嚕
    setMember(response.data);
    setIsLogin(true);
  }
 // front-end Navbar - logout.js
async function handleLogout() {
    let response = await axios.get(`${API_URL}/auth/logout`, {
      **withCredentials: true,**
    });
    console.log(response.data);
    setMember(null);
  }
```

### useContext() 用法補充 全站取用useState() [useHook](https://www.notion.so/useHook-9f90926d758b4c67b43bfbc3b39482c9?pvs=21)

通常useState()只存在於該component當中 如果有全站都需要查找 除了props 將值往下傳 還可以使用useContext() 

**此用法還可以更深入下一層取用ＴＢＡ**

基本用法：在此次練習當中 將設定全站都能查找 登入狀態取用

1. 後端建立查詢登入狀態的router, member.js 讓前端app.js可以打api回查登入狀態
    
    ```jsx
    // member.js
    const express = require('express');
    const router = express.Router();
    
    router.get('/', (req, res, next) => {
      // 判斷這個人是否已經登入
      //  session 裡面如果沒有member 資料
      if (!req.session.member) {
        //代表尚未登入 **回傳401 未授權而拒絕存取**
        return res.status(401).json({ message: '尚未登入' });
      }
      // 方法1 根據session 中儲存的member id 去撈資料庫將會員資料回給前端
      //      優點：資料比較即時正確
      //      缺點：一直去存取資料庫
      // 方法2 可以直接回覆session的資料
      // BUT  如果有提供會員修改資料的功能 更新成功後要更新session 資料
      res.json(req.session.member);
    });
    
    module.exports = router;
    ```
    

1. 前端開新資料夾 context 建立 auth.js 檔案
    
    ```jsx
    // auth.js
    
    import { createContext, useContext } from 'react';
    
    // 建立可以存放useState 資訊的容器
    export const AuthContext = createContext();
    
    // export 成useAuth()取用
    export function useAuth() {
      return useContext(AuthContext);
    }
    ```
    

1. 在全站最外層 app.js 使用查找  會員資訊
    
    ```jsx
    // app.js 
    // 引入左方建立的auth.js 容器資料
    import { AuthContext } from './context/auth';
    
    const [member, setMember] = useState(null);
    
      useEffect(() => {
        // 去要要看有沒有會員資料，有要到就是已經登入過 ->全站都適用檢查
        let getMember = async () => {
          console.log('in APP: check if login');
          let response = await axios.get(`${API_URL}/member`, {
            withCredentials: true,
          });
          setMember(response.data);
        };
        getMember();
      }, []);
    
    // 下方app 全站的元件包在最外層 把{member, setMemeber} 這兩個設成value 給下面元件取用
    return (
        **<AuthContext.Provider value={{ member, setMember }}>**
          <BrowserRouter>
            <Navbar />
            <Routes>
              <Route path="/" exact element={<Stock />} />
              <Route path="/about" element={<About />} />
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />
              <Route path="/stock/:stockId" element={<StockDetails />}>
                {/* <Route path=":currentPage" element={<StockDetails />} /> */}
              </Route>
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        **</AuthContext.Provider>**
      );
    ```
    
    [express 錯誤處理](https://www.notion.so/express-903da75fae2846e2b07b28100aa93271?pvs=21) 
    
    ```
    // 前面的中間件
     app.use((req, res, next) => {
       console.log('這裡是錯誤頁之前的 middleware');
       // next 如果是要去下一個中間件，就不要放任何參數
       next();
       // next 如果是想要直接跳去錯誤處理中間件 -> 加上任何參數
       // next(123);
      });
    //test error!!
    app.get('/err', (req, res, next) => {
      throw new Error('故意錯誤丟出來');
      // res.json({ message: '故意錯誤' });
    });
    
    // 務必要設定中間件錯誤處理 否則錯誤訊息會跑出來給使用者看到
    app.use((err, req, res, next) => {
      console.error('來自四個參數的錯誤中間件', err);
      console.error('查找哪個路由錯誤', req.path);
      res.status(500).json({ message: '請洽系統管理員' });
    });
    ```
    

1. 前端app底下的元件取用 範例 ： login.js/ navbar.js/about.js
    
    ```jsx
    // login.js
    
    // 把 member, setMember 從 auth context 裡頭拿出來
      const { member, setMember } = useAuth();
    // 如果api 登入成功 把 app 查找到的資料 更新渲染
    async function handleSubmit(e) {
        e.preventDefault();
        let response = await axios.post(`${API_URL}/auth/login`, loginMember, {
          // 為了可以跨源存取 cookie
          withCredentials: true,
        });
        console.log(response.data);
        // 告訴 auth context 會員有資料嚕
        setMember(response.data);
        setIsLogin(true);
      }
    ```
    
    ```jsx
    // navbar.js 
    // 把 member, setMember 從 auth context 裡頭拿出來
      const { member, setMember } = useAuth();
    // 如果執行 handleLogout 則 清空member 資料 （登出）
    async function handleLogout() {
        let response = await axios.get(`${API_URL}/auth/logout`, {
          withCredentials: true,
        });
        console.log(response.data);
        setMember(null);
      }
    ```
    
    ```jsx
    // about.js
    // 把 member, setMember 從 auth context 裡頭拿出來
      const { member, setMember } = useAuth();
    // 如果有值 代表登入 顯示對應資料 / 如果沒有值 代表登出 navigate跳回登入畫面
      if (!member) {
        return <Navigate to="/login" />;
      }
      **// 如果從 context 裡面拿，這裡就不用自己再去要一次 在app.js 已經有寫過一模一樣的code
      // const [member, setMember] = useState(null);
      // useEffect(() => {
      //   let getMember = async () => {
      //     let response = await axios.get(`${API_URL}/member`, {
      //       withCredentials: true,
      //     });
      //     setMember(response.data);
      //   };
      //   getMember();
      // }, []);**
    ```
    

## 補充

### A || B

```jsx
  A || B (A 或 B) 

const port = process.env.SERVER_PORT || 3002;

程式會先偵測Ａ是否為true / false 
若為 true 則不會繼續偵測
若為 false 則往下偵測Ｂ是否為 true
可以拿來當預設值的概念
 
```

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2021.png)

### ****Express.js req.params 用法****

**express 可藉由路由偵測取值(後端伺服器）**

若前端react 框架要抓url 取值則可使用useParam();

[後端express路由 從req.query取值及運算](https://medium.com/@aaa24295234/%E5%BE%8C%E7%AB%AFexpress%E8%B7%AF%E7%94%B1-%E5%BE%9Ereq-query%E5%8F%96%E5%80%BC%E5%8F%8A%E9%81%8B%E7%AE%97-77101d9abe18)

[[Express.js]取得網頁參數的三種方法](https://medium.com/ling-ni-lee/express-js-%E5%8F%96%E5%BE%97%E7%B6%B2%E9%A0%81%E5%8F%83%E6%95%B8%E7%9A%84%E4%B8%89%E7%A8%AE%E6%96%B9%E6%B3%95-39725d8f3211)

<aside>
👉🏻 req.params

當連到http://localhost/:here 網址時，:here為動態路由，會根據動態路由所產生不同的網址而回傳不同的資料

```jsx
 app.get(‘/user/:id’, function(req, res){
res.send(‘user ‘ + req.params.id);
});
// 輸入localhost:3000/user/123456，會得到user123456。**id還可以更換為任意值 (變數）。**
```

</aside>

<aside>
👉🏻 req.query

用來取得網頁搜尋欄輸入的資料，搜尋資料的回傳由form表單取得

當輸入localhost:3000/user?abc=123，使用req.query.abc，就能取出123。

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2022.png)

</aside>

<aside>
👉🏻 req.body

req.body用來取的POST表單送出的資料，使用上需再安裝一個middleware 「*body-parser*」

載入body-parser module後，需設定從POST表單或取的URL加密資料，**將它展開為object資料型態**，方便使用。

> 也可抓取從前端來的資料（前端在axios 裡面用post 方法將變數存成物件 傳回後端）
> 
> 
> ![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2023.png)
> 

<aside>
👉🏻 使用<input type=”checkbox” name=”test”>，後端取得方式：req.body，name則為req.body的key資料，若勾選則顯示”on”，無勾選則不存在此資料

Example：若網頁存在三個checkbox表單

```html
<form>
 <input type=”text” name=”word”> 文字
 <input type=”checkbox” name=”test1”> v（勾選）
 <input type=”checkbox” name=”test2”> v（勾選）
 <input type=”checkbox” name=”test3”>
</form>
```

使用body-parser取得資料

```json
req.body{
word:'文字',
test1:"on",
test2:"on"
}
```

</aside>

<aside>
👉🏻 使用<input type=”radio” name=”group” value=”test1”>，後端取得方式：req.body，value則為req.body的key資料，若勾選則顯示”on”，無勾選則不存在此資料，radio選單中，若name相同，在同一group只可勾選1個check。

Example：若網頁存在三個radio表單

```html
<form>
 <input type=”radio” name=”group” value="test1"> v（勾選）
 <input type=”radio” name=”group” value="test1">
 <input type=”radio” name=”group” value="test1">
</form>
```

使用req.body取得資料，

```json
req.body{
group:"test1"
}
```

</aside>

</aside>

![Untitled](%E5%BB%BA%E7%AB%8B%E4%BC%BA%E6%9C%8D%E5%99%A8%20simple%20web%20%E5%89%8D%E5%BE%8C%E7%AB%AF%E4%BA%92%E5%8B%95%20533583c06c814cabbb8ab5e160622359/Untitled%2024.png)

### javascript 數學計算

```jsx
Math.ceil(); //無條件進位
Math.floor(); //無條件捨去
```